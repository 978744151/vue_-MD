# 面向对象
## 01前奏（面向对象是什么）
### 要理解函数是什么，就相当于是一个工具
```
    alert();
```
> 就是一个封装好了的函数，只要会使用就好了，不用去理解里面的代码。

### 对象就是多个工具一起，就是工具包。
- （框架就是多个工具包。）
- 里面包含两个东西：函数、属性.
- 整个js都是面向对象的。
- 并不是一个新的知识点

### 01-2为什么使用面向对象

- 本质：就是为了团队协作，将庞大的功能分成好几个小功能，大家分别写自己的代码，彼此之间并不影响。

### 01-3怎么用代码层面来使用面向对象。
```
    //产品对象
    /*
    对象内如何使用对象的属性和方法：this，对象外如何使用：先实例化，后用点语法
    */
    function Product() {
        /*属性 行为 可以为空或者给默认值*/
    }
    Product.prototype={
        //方法
        buy:function(){

        },
        getPrice:function() {
            return this.price
        },
        addToCart:function(){
            alert('将物品添加到购物车')
        }

    }
```
- 一般就是把属性放在构造函数，方法放在原型。
- 写代码一定要写注释，不是为了高大上，而是为了看得懂。
- 对象的使用必须先实例化，对象定义好之后，都是抽象的，必须实例化成具体
```
    var iphone = new Product()
    iphone.name='iphone7'
    iphone.price=6000
```
 + 抽象 = 水果     具体 = 苹果。

### 01-4步骤
1. 拿到需求先思考需要哪些对象
2. 分析属性和方法
3. 实现功能
4. 实例化使用工具

### 01-5小总结
1. 思维转变，面向行为是先写细节。面向对象是先写架子，再慢慢补细节。
2. 面向行为代码不好管理，面向对象可以进行模块化开发。分工协作，互不影响。高内聚，低耦合。

## 02常用的一些绑定数据方法。
```
 bindDom:function(){
        var str=''
        str += '<br/>'
        return str;
    },
    bindEvents:function(){
        //绑定事件
    }
```
- 开发中一般就是两种情况：单个实例，多个实例。
  1. 开发多个实例，先将单个实例抽象出来。
  2. 通过for循环绑定数据
```
    for(var i = 0,len=products.length;i<len;i++) {
        var product = new Product()
        product.name=products[i].name;
        product.image=products[i].image;
        //绑定元素
        str+= product.bindDom()
    }
```
    3. 最后绑定容器
```
    var container = document.getElementById('container')
    container.innerHTML=str;
```

## 03面向对象的字面量形式
- json其实就是对象的一个实例。
```javascript
    //使用json表现一个对象
        var iphone = {
            description:'手机中的战斗机',
            addToCart:function(product){
                cart.products.push(product)
            }
        }
        //不需要实例，直接用点语法使用
        iphone.addToCart();
```
- json和js语言天生的契合，导致不需要实例化。
 + 有一点区别，就是js对象可以不写键的双引"":""。
- xml和json都是一种协议，前端json是非常流行的
 + json不是js语言，而是国际通用的。

### 03-1 json和字符串互相转换

>后端给的json是字符串，所以要转换

1. 将json对象转化成json字符串
 - JSON.stringify(obj)将JSON转为字符串
2. 将json字符串转化成json对象
 - JSON.parse(string)将字符串转为JSON对象  //parse：解析

#### json对象和json协议有什么区别？
- 两者并没有关系，json对象是js语言的对象，json协议是国际通用标准。

### 03-2xml协议
- 什么是XML
 + Xml只是描述数据的一种结构，比如大家常用的html就是采用这种结构描述的
- 在所有语言中，xml比json更通用，json就是xml演化来的。
- Web前端开发 json更流行

### 03-3例子
 - 用xml描述新浪新闻
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<News>
<head>
    <title>今日新闻热点</title>
</head>
<body>
    <head>
        <h11>习近平给在德国留学人员回信</hl1>
    </head>
    <by>
        <bytag>新华网</bytag>
    </by>
    <date>
        <location>北京</location>
        <date>2013年1月17号</date>
    </date>
</body>
</News>
```
 + 不是一种新语言，html就是xml语言。

### 03-4 xml json区别
- 相同点
  1. 都是一种通用协议
  2. 都可以用来描述数据
- 不同点
  1. JSON相对于XML来讲，数据的体积小，传递的速度更快些。
  2. xml占用带宽大，json占用带宽小
  3. json没有xml这么通用
  4. json可以和js对象互相转换，和js是天生的一对，因此广泛用于前端开发
- XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了

## 04 面向对象的三个作用
1. 面向对象编程
 - 任何页面，各个功能具现化成对象。
 - 单一职责原则 === 解耦合
2. 描述数据，比如ajax
 - 常用json对象来描述数据
3. 框架（兼容问题、封装性）在09部分详解 ---- jq angular

## 05构造函数和属性、原型
- 面向对象包含的不仅仅是js部分，html的拼接，css类的效果，都在其中。
- 比如一个购物车，所有里面的属性和行动都是封装到购物车对象里面。

### 05-1构造函数和普通函数的区别
- 一回事，构造函数通过普通函数实现

### 05-2使用构造函数创建属性的四种方式
```js
    /*传参形式*/
    function Product(name){
        this.name = name
    }
    Product.prototype={}
    var iphone = new Product('iphone8s')

    /*默认值*/
    function Product(){
        this.name = ''
        this.price=0
    }
    Product.prototype={}
    var iphone = new Product()
    /*动态添加形式*/
    iphone.description='XXXXXXXXXX'
    iphone.images=[]




    /*混合模式（常用）*/
    function Product(name,price){
        this.name = name
        this.price=price
        this.version=1.0
        this.add=function(){}
    }
    Product.prototype={}


    var iphone = new Product()
    /*动态添加形式*/
    iphone.description='XXXXXXXXXX'
    iphone.images=[]

    /*构造函数小知识点 instanceof
    就是为了判断一下这个实例是否为此构造函数创建的
    */
    console.log(iphone instanceof Product)//true
```

> 面试题

```js
    var fun1 = function(){
        this.name = 'peter';
        return {
            name: 'jack'
        };
    }
    var p1 = new fun1();
    console.log(p1.name)
/*
高级语言构造函数是没有return的
而js比较特殊，js构造函数本身就是一个函数，所以拥有函数的一切的特性
如果return一个对象，则new的时候返回的是return的对象

*/


    var fun2 = function(){
        this.name = 'peter';
        return 'jack';
    }
    var p2 = new fun2();
    console.log(p2.name)
    /*
        return的不是一个对象，答案为peter
    */
```
## 06属性进阶
### 06-1万物皆属性
```js
    function Product(){
        this.name=''
        this.add=function(){

        }
    }

    Product.prototype={

    }
```
### 06-2万物皆变量 - 一切数据都是通过变量来统一管理的
```
    var Product = function(){
        this.name='iphone'
        this.add=function(){}
    }


    Product.prototype={
        buy:function(){

        }
    }
```
1. 属性的取值器和设置器 get set
```
            Object.defineProperty(this,"price",{
                get:function(){return price*.6},
                set:function( value ){
                    if ( value > 500 ) {
                        console.log("价格太高请核实");
                    }else{
                        price = value;
                    }
                }
            });
```

- 通过get设置的值，使用对象的人员传进去的值都会是6折
- 通过set判断，如果传进去的值大于500，就会在控制台输出。
2. 包装器
```
        //添加一个属性包装器
        Object.defineProperty(this, "produceDate", {
            get: function () {
                // return produceDate.toLocaleDateString();
                return produceDate.toLocaleString();
            },
            set: function (value) {
                produceDate = value;
            }
        });
```

- 更改时间
- toLocaleDateString() 此函数会转换成本地年月日 生产日期：2017/4/11
- toLocaleString() 此函数会转换成本地年月日+时间 生产日期：2017/4/11 下午5:27:42

#### 拓展
```
    function dateFormat(date,format) {
        var o = {
            "M+" : date.getMonth()+1, //month
            "d+" : date.getDate(),    //day
            "h+" : date.getHours(),   //hour
            "m+" : date.getMinutes(), //minute
            "s+" : date.getSeconds(), //second
            "q+" : Math.floor((date.getMonth()+3)/3),  //quarter
            "S" : date.getMilliseconds() //millisecond
        }
        if(/(y+)/.test(format)) format=format.replace(RegExp.$1,
                (date.getFullYear()+"").substr(4- RegExp.$1.length));
        for(var k in o)if(new RegExp("("+ k +")").test(format))
            format = format.replace(RegExp.$1,
                    RegExp.$1.length==1? o[k] :
                            ("00"+ o[k]).substr((""+ o[k]).length));
        return format;
    }

    //产品对象
    /*对象内如何使用对象的属性和方法：this，对象外如何使用：先实例化，后用点语法*/
    /*类 -- 抽象对象*/
    function Product(name,price) {
        /*属性 行为 可以为空或者给默认值*/
        this.name=name
        this.price=0;
        this.description = '';
        this.zhekou = ''
        this.sales = ''
        this.produceDate
        /*我们的需求：自动计算打折后的价格*/
        Object.defineProperty(this, "price", {
            get: function () {return price*0.9;},
            set: function (value) {
                /*大概普通产品的价格都在0--1万*/
                if(value>10000)
                {
                    alert('产品价格必须在0--1万之间');
                }else{
                    price = value;
                }
            }
        });
        Object.defineProperty(this, "produceDate", {
            get: function () {
                return dateFormat(produceDate,'yyyy-MM-dd');
            },
            set: function (value) {
                produceDate = value;
            }
        });
    }
```
- 封装一个自己的日期函数

### 兼容性
- 因为这是ECMAScript 5新增特性。所以老版本浏览器不一定支持
- 如果不考虑兼容低端浏览器，可以使用
- 支持浏览器：Chrome 32、IE 9、FireFox 28、Opera 19、Safari 5.1.7

### js设置属性权限
#### 给属性添加权限的必要性
- 比如 文件系统 我们可以设置只允许访问,不可以修改
- 如何设置某个属性可读
- 如何设置??

#### defineProperty设置权限
- Object.defineProperty(a,b,c);
- 例如：Object.defineProperty(this,"num",{
  value:200,
  writable:false,
  });
- this指向当前对象，num是当前对象的属性需要加引号，设置的值固定为200
- writable 判断是否能修改，默认为ture，false则无法修改

#### 关于第三个参数：
- 是一个用于描述属性值得json数据.
- 这个json数占领configurable，eumerable，writable，value构成
- configurable:1.可否被删除，2.他的属性值可否被批改.3.可否把属性设置成接见器属性，默认是true，可以删除，，批改，设置
- eumerable:可否被for-in轮回到
- writable:默示属性值可否被批改
- value:属性值.
#### 兼容性
- 因为Object.defineProperty方法是ES5的一部分，所以在IE9及现代浏览器，IE8中只得到了部分实现。但是，如果你不需要处理旧的浏览器，defineProperty可能会有你使用的地方。
3. 公有属性和私有属性
- 公有属性：当实例化一个对象，可以进行访问的。
```
this.name = name;
this.publicFunction = function () {
 alert(this.name);
 alert(className); //调用私有属性，直接写变量名
}
```
- 私有属性：只能在对象构造函数内部使用
```
var className = "用户对象";
var privateFunction = function () {
    alert(this.name);
}
```
 + 私有属性好处： 安全 就类似闭包中的函数一样 减少污染
- 最小原则：尽量只给用户暴露一个方法。


## 07实例化的本质
- 两个概念
1. 一切数据通过变量来管理
 + 关于内存
```
 内存就像电话黄页，
 变量 == 电话号码
 对象 == 家庭住址
 电话号码可以直接拨打，但是要找上家门，是通过家庭住址去找。

 实例化的时候会把构造函数里面所有的东西都拷贝一份，同时附上默认值，除了拷贝以外还会自动生成一个constructor属性，用于识别其是根据哪个构造函数创建的实例。一旦给实例附上新的值，就会将内存空间的值替换掉。
  就像房地产商建房子，所有毛胚都一样，怎么装修是用户的事情。

    constructor其实是构造函数里面的隐藏属性，实例拷贝所有的构造函数属性，所以这俩就能对上
```
2. 定义变量的过程其实就是内存分配的过程,所以本质上一切数据都是存放在内存中的.

### 07-1了解数据类型
 ```
    1.数值型（Number）：包括整数、浮点数。
    2.布尔型（Boolean）
    3.字符串型（String）
    4.对象（Object）
    5.数组（Array）
    6.空值(Null)
    7.未定义（Undefined）
 ```

## 08 原型进阶 --> 理解原型对象中的属性和方法被所有实例共享
- 既然我们可以使用构造函数就可以定义属性和方法，为什么还要原型呢？
 + 实例化会占一个内存空间，将相同的属性放到原型节省空间。
 + 原型对象无论你实例多少次，都只占一个空间。
- 实例化的时候只拷贝构造函数中的属性，而没有拷贝原型，为什么还能用原型里面的属性？
 + 属性搜索机制。先找自身的属性，如果没有就去prototype中找。
 + prototype保存的是原型对象属性的地址
 + 本质：通过prototype链接原型地址。

> 一般将大家都公有的东西放在原型对象中
> 每个实例独特的不一样的属性放在构造函数中

 + 原型对象的属性和方法可以被所有实例共享。这样，如果我们需要修改所有实例中的属性或者方法，就只需要修改一处，就能够影响到所有实例了

### 08-1双对象法则
- 一个对象包含两个独立的对象：构造函数对象和原型对象。它们通过_proto_属性关联到一起（早期IE不支持，但这个是主流了。）
- 这个就是原型链
### 08-2属性屏蔽理论
```

    function Product(){
        this.name='111';
    }

    Product.prototype={
        name:'222',
    }

//构造函数和原型有两个相同的属性或者方法，就访问不到原型中的属性和方法。

    var product = new Product()
    /*原型属性屏蔽理论 -- 乌云蔽日*/
    console.log(product.buy())

    /*清除乌云，通过此方法可以清掉构造函数中的buy方法。*/
    delete product.buy
    console.log(product.buy())

/*也可以通过原型方法直接获取 */
//        console.log(Product.prototype.buy())

```

## 09 面向对象三个作用（进阶）
### 封装框架
```js

function Zzc(){

}
Zzc.prototype = {
    $id:function(id){
        return document.getElementById(id);
    },
    $tag:function(tag){
        return document.getElementsByTagName(tag);
    }
}
/*
这就是最简单的一个框架了,本质就是把一些常用的代码放到一个对象里面。
*/

```

## 10 bindDom的三种方式（绑定数据）
1. 原生
```
    var alink = document.createElement("a");
    alink.setAttribute("id", "login");//设置属性
```
2. formateString，其实就是replace实现的。
```
//先看使用方法
    var span = document.getElementById("span");
    span.innerHTML = formateString("欢迎@(name)来到百度世界",user)

    //放到$框架使用
     var span = document.getElementById("span");
     span.innerHTML = $.formateString("欢迎@(name)来到js世界",user)


    //具体函数实现
    function formateString(str, data){
        return str.replace(/@\((\w+)\)/g, function(match, key){
            return typeof data[key] === "undefined" ? '' : data[key]});
    }
```
3. arttemplate模板，通过js来实现数据与html绑定。
 - 使用方法
  + 引包 template.js   网上可下载到
```
//先定义一个模版内容
    <script id="arttemplate" type="text/html">
        <strong>电影名称：</strong>{{name}}<br>
        <strong style='color:red'>导演</strong>{{lead}}<br>
        <strong style='color:green'>主演:</strong>{{role}}
    </script>

//随便给的一个json对象的数据
    var film = {
        name: "没人鱼",
        lead: "周星驰",
        role: "邓超",
    };

//绑定数据到容器中， template('模板id'，数据)

    var html = template('arttemplate', film);
    document.getElementById('mydiv').innerHTML = html;
```
  + 多个列表的固定用法
```
<script id="arttemplate" type="text/html">
    <h2>{{name}}</h2>
    <ul>
        {{each films}}
        <li>
            <strong>电影名称：</strong>{{$value.title}}<br>
            <strong style='color:red'>导演</strong>{{$value.lead}}
            <strong style='color:green'>主演:</strong>{{$value.role}}
        </li>
        {{/each}}
    </ul>
</script>

<script>

    //定义数据
    var data ={
        name:'电影列表',
        films:
                [
                    {
                        title: '复仇者联盟2',
                        lead: '乔斯·韦登',
                        role: '小罗伯特·唐尼'
                    },
                    {
                        title: '速度与激情7',
                        lead: '范·迪塞尔',
                        role: '范·迪塞尔'
                    },
                    {
                        title: '左耳',
                        lead: '苏有朋',
                        role: '苏有朋'
                    },
                    {
                        title: '万物生长',
                        lead: '范冰冰',
                        role: '范冰冰 韩庚'
                    },
                    {
                        title: '盗墓笔记',
                        lead: '苏有朋',
                        role: '美人鱼'
                    }
                ]
    }
    $$.BindTemplate(data,'mydiv','arttemplate')
</script>

```

### 10-1还有一种绑定数据的写法
```
//就是不在script标签里面绑定html结构
    var film= {name:'美人鱼',lead:'周星驰',role:'邓超'}
    var source = '<strong>{{name}}</strong>'
            +  '<strong>{{lead}}</strong>'
            +  '<strong>{{role}}</strong>'

    // template.compile(你的html结构)   compile：编译
    var render = template.compile(source);

    // 你的data
    var html = render(film)
    document.getElementById('content').innerHTML = html;
```

## 11 js中的引用类型
```
    var num1; //这个时候不进行内存分配
    var num3=9;//分配内存
    var num4=num3;//会不会分配？
```

- 变量中的引用类型

> 答案是会分配类型。

```
    num3=3333333;
    num4=4444444;
    console.log(num3)
    console.log(num4)
    //当更改数据，值不一样的本质是这里分配两个空间独立存储
```

- 字符型
```
       //字符串
        var str1; //这个时候不进行内存分配
        var str2 = 'zzc'; //分配内存
        var str3=str2; //问题，分配内存?
        //分配
```
- 数组
```
        var arr1=['zzc','ccz'];//arr1分配内存
        //引用类型其实是指向同一个地址,也就是操纵的其实是同一个位置
        var arr2=arr1;   //问题：这里arr2会不会分配内存
        console.log(arr1[0]);
        console.log(arr2[0]);
```

> 答案是不会给arr2分配内存空间，只会分配内存地址。

- 函数
```

      function sum(num1,num2)
      {
        return num1 + num2;
      }
      console.log(sum(10,10)); //20
      var anotherSum = sum;
```

> 答案同数组

- 对象
```
      function product(){

      }
      var pro1 = new Product();
      var pro2 = new Product();
```

> 答案同数组、函数

### 11-1 原因
- 变量和字符串都会创建自己的内存空间，var a = b；相当于给a，和b都分别创建了一个内存。
- 数组，函数，对象则是复制内存地址，地址指向真正的内存空间（指针）。

### 11-2小结
```
        function show(x) {
        console.log(typeof(x));    // undefined 值类型
        console.log(typeof(10));   // number 值类型
        console.log(typeof('abc')); // string 值类型
        console.log(typeof(true));  // Boolean 值类型

        console.log(typeof(function () { }));  //函数 引用类型
        console.log(typeof([1, 'a', true]));  //数组  引用类型
        console.log(typeof ({ a: 10, b: 20 }));  //object 或者json  引用类型
        console.log(typeof (null));  //null  引用类型
        console.log(typeof (new Number(10)));  //内置对象 引用类型
    }
    show();
```
- 其中上面的四种（undefined, number, string, boolean）属于值类型，不是对象。
- 函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。
- 在最新语法中，null和undefined已经合并了。

### 11-3 面试题
#### 1
```
      var a = {"x": 1};
      var b = a;
      a.x = 2;
      console.log(b.x);
```
> 结果是？
#### 2
```
      var a = {"x": 1};
      var b = a;
      a.x = 2;
      console.log(b.x);
      a = {"x":3};
      console.log(b.x);
```
- 答案：
* 第一题 2
* 第二题 2 2
- 解析：
* 第一题，json对象是引用类型，所以a.x更改了真实内存的值,b指向该内存地址。
* 第二题，a是创建了一个新的对象,所以它指向原来的指针断了，而b仍然指向原地址。


### 11-4补充
- 内存分两种：栈内存，堆内存。
  1. 栈内存只能保存单个单个的值。
  2. 堆内存可以保存多个值。

> 所以，值类型和引用型就可以很好区分了

- 值类型都是保存在栈内存中，引用类型将内存地址保存在栈内存。（和数组的获取方式类似）
- 引用类型的数据会保存在堆内存。

       var p = new Product();

> 那么p就是在栈内存，真正的对象里面属性什么的都在堆内存。

## 12 memory-release（内存回收机制）

> 每个函数都有自己的生命周期

### 12-1 内存分配

- 当我们声明变量、函数、对象的时候，系统会自动给他们分配内存空间
- 使用完毕，会被js的内存回收机制自动回收。
#### 栈和堆内存
- 存放在栈内存的数据，就像数组一样，每调用一次相当于数组+1;
- 当数组长度为0的时候就释放内存
#### 堆内存
- 引用计数
> 创建一个构造函数，当每实例化一次引用计数+1.
> 同样的当没有人再调用他的时候，内存自动释放
#####
> 至于怎么回收，那就是更底层的内容了。。。有关于c++什么的，暂时还不懂

### 12-2 内存泄漏
> 就是指一个内存，既不能被使用又不能被释放。
- 在C语言中特别恶心，像java和js这类语言比较少会遇到这类问题。
- 能玩好内存的公司，一般都是有大牛的。


## 13 create Object（多种方式创建对象）

1. 内置对象形式 new Object
```
    //利用内置对象形式创建
    var boy = new Object();
    //属性
    boy.name = 'JUGG';
    //属性
    boy.image = '最新至宝';
    //属性
    boy.HealthPoint_HP = 500;
    //属性
    boy.MagicPoint_MP = 200;
    //技能
    boy.technologys =['F':'剑刃风暴'];
    //方法
    boy.attack = function(){
    }

    var girl=new Object();
    girl.name='露娜';
```
  - 获取对象值的方法
> boy.name;//常用方法
> > boy['name'];//动态编程中常用的方法（重要）。

2. 工厂模式

> 就像生活中的工厂，我们不用关心他是怎么做出来的，负责用好他的产品就行。

    function createPerson(){
            //1.原料
            var obj = new Object();
            //2.加工
            obj.name = '露娜';
            obj.HP=100;
            obj.MP=100;
            obj.technologys=['普通攻击','c','光环','e'];
            obj.attack = function(){
                alert(obj.name+'发出攻击，导致对方10点伤害值')
            };
             obj.run = function(){
             };
             //3.出场
             return obj;
    
        }
    
        var boy = createPerson();
        boy.attack();

- 在函数内部已经实例过了，所以直接拿来使用。
- 在生活中工厂产出就是产品，这里的工厂产出就是代码。
- 使用场景，一些函数确实是默认值的情况下，就把这类做成原料，减少使用者考虑问题的时间。
- 与构造函数的区别，不用实例化和return。
- 设计模式：工厂模式（后端的顶级模式）
> 实际工作中：在函数中直接实例化，return带有默认属性的变量。
> 使用：拿到后端接口，并把接口传进函数中使用。
```
        function Product(){
            //实例
            var obj = new Product();
            //默认值
            obj,name = '';
            //return
            return obj;
        }
        //使用
        var p = Product( data );
        //使用后端给的数据data
        p.name = data.name;
```
### 缺点:

> 太占用内存了，每次使用都要实例化一次。
> 所以引出下面一个方法，原型创建对象。

## 原型创建对象
```
    var Role2 = function(){
      Role2.prototype.name = 'dotaer';
      Role2.prototype.technologys = ['',''];

    }
```

> 很好的解决了重复使用的问题，但是又会冒出新的问题。

```
      var Role2 = function(){
      Role2.prototype.name = 'dotaer';
      Role2.prototype.technologys = ['zzc','czz'];

      }
    var r1 = new Role2();
    r1.name = 'dota1';
    console.log(r1.name);//dota1
    var r2 = new Role2();
    r2.name = 'dota2';
    console.log(r1.name);//dota1
    console.log(r2.name);//dota2
```

- 虽然原型中的引用型都会被实例共享，但是里面的值类型却各干各的。
```js
      var Role2 = function(){
      Role2.prototype.name = 'dotaer';
      Role2.prototype.technologys = ['普通攻击','隐身','飞镖','标记'];
      }
      var r1 = new Role2();
      var r2 = new Role2();
      r2.name = 'dota2';
      console.log("r1   "+r1.technologys.length);//4
      r1.technologys.push('点灯');//添加一个数组
      console.log("r2   "+r2.technologys.length);//5
```

> 这里有个问题没有解决，为什么用英文字符串会是如下效果。想不通...

```js
      var Role2 = function(){
      Role2.prototype.name = 'dotaer';
      Role2.prototype.technologys = ['zzc','czz','zcz'];
      }
      var r1 = new Role2();
      r1.technologys.push('zzczz');
      var r2 = new Role2();
      r2.name = 'dota2';
      console.log("r1   "+r1.technologys[2]);//zcz
      console.log("r1   "+r1.technologys[3]);//undefine
      console.log("r2   "+r1.technologys[2]);//zcz
      console.log("r2   "+r2.technologys.length);//3
```

> 讲道理，并没有给原型的数组push。为什么中文字符串的r2就有3的长度，而英文却push不了呢。

- 问题还是很明显的

3. 双对象法则-混合模式
```
    function Fn( option ) {
        this._init( option );
    }
    Fn.prototype = {
        _init:function( option ){

        },
        action:function(){

        }
    }
```

> 或者

```
    var Role =function() {
      this.name = {nickName:'张三',accountName:'774143745@qq.com'};
    }
    /*姓名*/
    //生命值
    Role.prototype.HP=100;
    //魔法值
    Role.prototype.MP=100;
    //技能
    Role.prototype.technologys=['普通攻击','灼烧烈焰','地狱火','骨隐步'];
    //跑起来
    Role.prototype.run=function() {
        alert('run');
    }
```

> 就是属性和那些要共享的东西放在里面，方法放外面。

### 字面量对象
```
    var boy = {
        name:'张三'
        ,image:'头像'
        ,age:20
        ,sex:'男'
        ,HP:100
        ,MP:100
        ,technologys:['普通攻击','灼烧烈焰','地狱火','骨隐步']
    };

    //将对象转换成字符串
    console.log(JSON.stringify(boy));
    //将字符换转换成json对象
    var sboy='{"name":"剑侠客","sex":"男","HP":100}';
    var objBoy = JSON.parse(sboy);
    console.log(objBoy.name);
```
- 后端传来的数据是字符串，不能直接用json对象来取，需要进行转换；
4. 拷贝模式
- 这里就是有个expend的函数，拷贝对象里面的属性方法用的，可多个可单个。
```
        /*函数的用处：就是将一个json对象 所有属性拷贝给另外一个对象*/
        /*source：想要拷贝其数据的 原始对象*/
        /*target：想要拿到数据的对象*/
        function extend(target,source) {
            //遍历对象
            for(var i in source){
                target[i] = source[i];
            }
            return target;
        }
        //游戏随机生成名字
           var boy = {
            name:'郭靖'
            ,image:'头像'
            ,age:20
            ,sex:'男'
        };
        var girl = {
            name:'黄蓉'
            ,age:18
            ,image:'女性头像'
            ,sex:'女'
        };
        /*六大神器之一*/
        var zuixiake = extend({}, boy);
        var huangrong = extend({},girl)
        alert(zuixiake.name);
        alert(zuixiake.sex);
        console.log(huangrong.name)
```
> 这个函数在框架中的应用非常广，号称六大神器之一。

### 13-1 拓展
```
    //extend2实现的功能：extend(target,obj1,obj2,obj3)
    /*功能：将多个多个json拷贝给目标*/
    /*原理：*/
    /*首先找到target   --arguments[0]*/
    function extend () {
        var key,i = 0,len = arguments.length,target = null,copy;
        if(len === 0){
            return;
        }else if(len === 1){
            target = this;
        }else{
            i++;
            target = arguments[0];
        }
        for(; i < len; i++){
            for(key in arguments[i]){
                copy = arguments[i][key];
                target[key] = copy;
            }
        }
        return target;
    }

    /*hasOwnProperty*/
    function extend2(){
        for (var p in source) {
            if (source.hasOwnProperty(p)) {
                target[p] = source[p];
            }
        }

        return target;
    }


    //游戏随机生成名字
    var boy = {
        name:'无忌'
        ,image:'男性头像'
        ,age:20
        ,sex:'男'
    };


    //技能名称，等级，伤害值，需要的魔法
    var technology = {tname:'亡灵复活',tlevel:10,tstrength:3000,tmagic:30};

    var shenqi = {sname:'霜之哀伤',slevel:30,sstrength:3000}
    //当这个人有了穿上盔甲，圣衣，六神合体，戴上魔法戒指之后，自动也拥有一个技能


    //第一种用法
    var zuixiake = extend({}, technology,shenqi);
    zuixiake.name='醉侠客';
    alert(zuixiake.name);
    alert(zuixiake.tname);
    alert(zuixiake.sname);


    //第二种用法
    extend(boy,technology,shenqi);
    alert(boy.name);
    alert(boy.tname);
    alert(boy.sname);
```

> 供研究


## 14 BOM:浏览器对象模型的简称

> Browser Object Model 这部分就是复习一下bom的函数

- 打开一个浏览器，里面的所有功能都是BOM对象

> 窗口（打开的网页整体看做一个窗口）、屏幕（网页是显示在一个屏幕上的）、导航栏、历史访问记录、标题、网页主题内容、地址栏、收藏

> 我们将打开的整个网页看做窗口对象,窗口对象中封装了和窗口相关的属性和方法，比如打开一个窗口，关闭一个窗口。

>> 最常见的一个：window.open（）;里面有许多的参数
>> innerHeight | pixel value | 窗口中文档的像素高度
>> innerWidth | pixel value | 窗口中文档的像素宽度

- 可以说万物都是window对象

> 定义一个全局变量num或者函数fn

> 都可以使用window.num或者window.fn来直接调用

### 14-1 Window 内置全局属性和方法
1. 全局常量: Infinity, NaN, undefined, null
2. 全局方法: eval(), isFinite(), isNaN(), parseFloat(), parseInt(),decodeURI(),decodeURIComponent(), encodeURI(), encodeURIComponent()
>  对话框
3. alert() 函数：弹出消息对话框（对话框中有一个OK按钮）confirm() 函数：弹出消息对话框（对话框中包含一个OK按钮与Cancel按钮）prompt() 函数：弹出消息对话框（对话框中包含一个OK按钮、Cancel按钮与一个文本输入框）
> 时间等待与间隔函数
4. setTimeout() 函数   clearTimeout() 函数    setInterval() 函数    clearInterval() 函数
> 获取失去焦点
5. focus() 函数：使窗体或空间获得焦点    blur() 函数：使窗体或控件失去焦点

### 14-2 相关的知识点
1. 指数表示法
> 如果数字巨大，可以使用指数表示法
> > 比如：
> > > 1e1表示在1后面加1个    0 ：10
2. NAN
> 它表示’不是数字‘的数字,事实上他是一个数字类型：
> > typeof NaN  ：number
> > > 如果我们再数字运算中使用了不恰当的操作数，导致运算失败，该运算就会返回NaN
> > > > 例如:var a = 10 * 'f'  --- NaN
3. parseInt&parseFloat
> 将输入的值转换成数字
> parseInt('123')
> > parseFloat('1.2ab')//1.2
4. inNaN
> 确定某个数值可以参与运算 inNaN(123);
5. eval
> 会把里面的字符串当做js代码来执行
## 地址栏对象（标重点）
> 地址栏window.location
- 面向对象的方法分析地址栏

### 14-3 大概包含了如下属性
1. URL网址：http://www.baidu.com
2. 协议：http ftp
3. 端口号：默认80
4. 查询字符串？name=zzc&&password=123456
- url属性
> 我们在浏览器的地址栏里输入的网站地址叫做URL(Uniform Resource Locator，统一资源定位符)。
> > 就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。
> > > 当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址
- 协议
> 协议是一种规定，只要你按照这个格式就能实现想要的功能。

> 比如只要你在地址栏中输入一个网址就能打开一个网页，这就是http协议.

> HTTP协议是用来浏览网站的.

> FTP是用来访问和传输文件的,FTP文件传输有点批量上传和维护网站的意思.

> 简单说HTTP是面向网页的，而FTP是面向文件的。

- 其他协议
  1. 文件传输协议FTP
  2. 电子邮件传输协议SMTP
  3. 域名系统服务DNS
  4. 网络新闻传输协议NNTP

- window.location也可以做成window.open的效果。

## 历史访问记录对象
```
    document.getElementById('btn').onclick=function() {
        /*改变当前窗口的地址，则会打开新的网页*/
        window.location ='test2.html'
    }

    document.getElementById('btn1').onclick=function() {
        history.back()
    }

    document.getElementById('btn2').onclick=function() {
        history.forward()
    }
```

### 网页的核心-DOM

> 学习DOM，其实就是学习增删查改



## 15 深入了解所有函数实例的鼻祖Function
### 15-1 argument(超级重点)
> 基本上是所有公司的必考面试题

- 它代表对象的实例
```
        function checkVarCount(a, b) {
            if (checkVarCount.length == arguments.length) {
                alert("形参和实参个数一样");
            }else{
                alert("形参和实参的个数不一样");

            }
        }
```
1. 形参就是函数写好,先填上去的参数,如a,b
2. 实参就是用户传进去的实际参数
3. arguments只有在代码运行的时候才起作用
4. arguments是一个数组，保存函数的参数 -- 准确的说是伪数组

### 15-2 call

#### call的作用
1. 借用另外一个对象的方法,而不用拷贝.
2. 将一个伪数组变成一个真数组

- 供爷法则

```
      //对象1
     var myclass={
         get:function(){
             return 130
         }
     };
      //对象2
      var student={
         getDetail:function(){
             return {name:'莉莉',aihao:'唱歌跳舞'}
         }
     };
      //借用 -- 供爷法则
    console.log(myclass.get.call(student))
```

> 为什么叫供爷法则呢?

> 因为借给你的那个债主写在前面
- 如果你需要传参数

```
      console.log(myclass.getAllStudentsNumbers.call(student,10,200))
```
- 另外一种方法
```
      function add(a, b) {
        alert(a + b);
      }

      function sub(a, b) {
        alert(a - b);
      }
      add.call(sub, 3, 1);//4
```

> call也能使用在函数上,因为函数也是一种对象                                                         
### call的使用方法

- 用于改变this
```
      var value="全局变量";
      /*函数中默认this指向window*/
      function Fun1(){
        console.log(this.value);//当前this=window
      }
```

> 所有的全局变量都指向window对象

    Fun1.call(window);

> 指向的仍然是window,因为fun1自己指向的就是window

```
        function Fun1(){
          console.log(this.value);
        }
        Fun1.call(document.getElementById('myBtn'));
        //改变this指向自身,这回指向了myBtn.会得到此btn的值
```


#### 伪数组:就是一个带有length属性的json对象,它的key都是1,2,3,...开头的
1. 它和真数组的区别:

> 都是模拟集合

> 伪数组每次都要自己去计算length的个数,自己去拼装对象

> 真数组有自己的方法:push pop join....

> document.getElementsByTagName("div")和argument这些都是一个伪数组

```
    var divs = document.getElementsByTagName("div")
    console.log(divs.length)
    /*说明他不是一个数组，无法访问里面的方法*/
    divs.pop().style.background='green'//会报错
```

> 使用如下方法,可以转换成真数组

```
    /*Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组*/
    /*这是一种固定用法*/
```

> jQuery和其他很多框架就是通过伪数组实现的

#### 实际用法例子
```
        function add(){
          var sum=0;
       /* arguments.push(10)  //报错*/
          var arr = Array.prototype.slice.call(arguments)
          arr.push(10)  //报错
          for(var i=0;i<arr.length;i++){
              sum+=arr[i]
          }
          return sum;
        }

    var sum = add(1,2,3,4,5)

    console.log(sum)
```

#### 你也可以自定义一个伪数组
```
    var fackArray1 = {0:'first',1:'second',length:2};
    Array.prototype.slice.call(fackArray1);//  ["first", "second"]

    var fackArray2 = {length:2};
    Array.prototype.slice.call(fackArray2);//  [undefined, undefined]
```

### 15-3 apply
- apply和call的功能,一毛一样.
- 仅一点,传参不一样
> call是平铺传参的
```
    //借用 -- 供爷法则
    console.log(myclass.getAllStudentsNumbers.call(student,10,200))
```

> apply则是把所有参数放到数组里面

```
    //借用 -- 供爷法则
    console.log(myclass.getAllStudentsNumbers.apply(student,argument))
    //相当于
    console.log(myclass.getAllStudentsNumbers.apply(student,[10,200]))
```

### 作用
> 很多时候在框架中需要用到一些算法,有关于数组的

> 常用写法:

```
    /*传统方式写法*/
    function getMax(arr){
        var arrLen=arr.length;
        for(var i=0,ret=arr[0];i<arrLen;i++){
            ret=Math.max(ret,arr[i]);
    }
    return ret;
    }
    console.log(getMax([1,2,3,4,5,6,7]))
```

> 这么写太麻烦,可以运用apply的巧妙特性来简化.

```
    function getMax2(arr){
        return Math.max.apply(null,arr);
       /* return Math.max.call(null,1,2,3,4,5);*/
    }
    console.log(getMax2([1,2,3,4,5,6,7]));
```

> 有非常多的运用常见要用到apply,划重点~

> apply经常用来处理数组的计算问题

### 15-4 caller

> 返回函数调用者

> caller的应用场景 主要用于察看函数本身被哪个函数调用

```
        function fn() {
        //        判断某函数是否被调用
                if (fn.caller) {
                        alert(fn.caller.toString());
                } else {
                        alert("函数直接执行");
                }
        }
        function AAAA() {
                fn();
        }
        AAAA();
```

### 15-5 callee
- 返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文.
- callee是arguments 的一个属性成员，它表示对函数对象本身的引用
- arguments.callee.length可以获取实参参数

> 可以用来判断实参和形参是否一致

> 较常用于递归

- 什么是递归:一个方法，自己调用自己，用上一次调用得出的结果作为这次的参数

```        
        //传统的递归
        var fn=function(n){
                if(n>0)
                return n+fn(n-1);
                return 0;
        }
        alert('采用传统方式'+fn(10))
        


        //callee的递归方式
        var fn=(function(n){
        if(n>0)
        return n+arguments.callee(n-1);
        return 0;
        })(10);
        alert('采用callee方式:'+fn)
```

### 传统方式的缺点:
1. 破坏了,零重复法则,当一旦函数名称更改,需要更改多处
2. fn是一个全局变量,fn内部一般使用局部变量,而这里是一个全局变量,这是一个潜在的全局变量污染
- 递归的好处:这样就让代码更加简练。又防止了全局变量的污染.

### 15-6 constructor
```
    function Student(name) {
        this.name = name;
    }
    var zhangsan = new Student('张三');
    if (zhangsan.constructor == Student)
    document.write("zhangsan是根据构造函数<strong>Student</strong>创造（实例化）出来的"+"<br />");
```

> 就是用来判断实例的构造函数是谁的属性.

### prototype

> 当定义好一个函数的时候,会自动生成一个prototype属性

```
    var product = function(){}

    /*自动有一个 prototype属性 它是一个对象--- 原型对象*/

    product.prototype.buy=function(){}

    product.prototype={}
```

### object
- object的__proto__指向Function对象的原型

```
        //Object对象是Function对象的一个实例
        console.log(Object.__proto__ === Function.prototype)
        /*Function.prototype对象的原型的__proto__属性指向Object.prototype*/
        console.log(Function.prototype.__proto__ === Object.prototype)
        /*object的原型的__proto__属性为null*/
        console.log(Object.prototype.__proto__ )
```

- 总结:一个自定义对象可以访问到Function对象的所有属性和方法，也可以访问到Object对象的所有属性和方法
### 内置对象的实例指向
> 全都指向Function.prototype
```
    console.log(Number.__proto__ === Function.prototype)  // true
    console.log(Boolean.__proto__ === Function.prototype) // true
    console.log(String.__proto__ === Function.prototype)  // true
    console.log(Object.__proto__ === Function.prototype)  // true
    console.log(Function.__proto__ === Function.prototype) // true
    console.log(Array.__proto__ === Function.prototype)   // true
    console.log(RegExp.__proto__ === Function.prototype)  // true
    console.log(Error.__proto__ === Function.prototype)   // true
    console.log(Date.__proto__ === Function.prototype)    // true
    var obj = new Object()
    /*object的实例指向Object的原型对象*/
    console.log(obj.__proto__ === Object.prototype);
```

### 自定义对象的原型链
```
    function Product(){}
    Product.prototype={

    }
    var iphone = new Product()
    console.log(Product.prototype.__proto__)
```
- 总结:一个自定义对象可以访问到Function对象的所有属性和方法，也可以访问到Object对象的所有属性和方法

- object.prototype是一切链式循环的终点    老大

- function.prototype可以理解为老二

## Object-character 面向对象三特性-多态、继承、封装性

> 只讲多态和继承

### 继承

> 字面意思,继承上一辈的东西.

> 需要拥有父级的基础,又拥有自己的个性。否则就叫做copy。

- 为什么要使用继承?

> 把相同的东西放到基类/父类

> 本质是为了避免重复,统一管理对象集

> 实现继承的代码

```
    /*父子类*/
    var Father = function(){
        this.type = 'person';
        this.age = 45;
    }
    Father.prototype = {
        takeMoney:function(){
            console.log(20000);
        }
    }
    var Son = function(){
        //固定用法
        Father.call(this.arguments);
    }
    Son.prototype = new Father();
    Son.prototype.stuy = function(){
        console.log('study');
    }
    var xiaoMing = new Son();
    console.log(xiaoMing.type);//person
```

### 多态

> 比如淘宝上买东西
> 大家都有buy这个方法,但是买的过程肯定不一样.
> 你买实物,要下单,等物流,收货
> 买电影票,只要下单,扫码就可以了.

- 对象的多态,方法的多态

### js不支持重载，最多间接实现它
- 常用的就是argument.length来进行判断参数。
- typeof也可以，判断传的类型。

##　面向对象总结
1. 面向对象的编程思维
 - 学会提炼属性，方法。
2. 构造函数
 - 基础
 - 进阶
 - 实例拷贝
3. 原型对象
4. 属性进阶
 - 双对象法则
 - 私有属性
 - 公有属性
5. 原型链
 - 属性搜索机制。
 - 继承的原型链。
6. 面向对象的三个作用
 - 面向对象编程
 - 封装框架
 - 描述数据
7. 从对象认识js世界
 - BOM
 - 内置对象
 - 自定义
 - Function
 - 鼻祖之间的原型链
8. 从内存方面认识js
 - 引用类型和值类型
 - 原型共享的本质
 - 堆栈
9. 对象三大特性
 - 多态
 - 继承
 - 封装性


## 编程小tips
1. 变量名称最好拷贝，不要自己写。
2. 编程的时间，70%在思考。
3. 对象中绑定html一般是用str拼接的形式，str+=,然后return这个值。绑定完了html再把里面的动态数据替换成this.属性。
4. 函数声明和函数表达式
```
    function fn(){
        alert('我是函数声明，我可以提升到顶部);
    }
    var fn = function(){
        alert(我是函数表达式，我无法被提升到顶部)
    }
```
5. javascript判断属性的四种方法
- typeof
```js
 console.log(typeof undefined)//'undefined'
 console.log(typeof null) // well-known bug
 console.log(typeof true) //'boolean'
 console.log(typeof 123)  //'number'
 console.log(typeof "abc")  //'string'
 console.log(typeof function() {}) //'function'
 console.log(typeof {}) //'object'
 console.log(typeof [])//'object'
 console.log(typeof unknownVariable) //'undefined'
```
- Typeof存在的问题
- 在使用 typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象（[] {} ），它都返回 "object"。

- toString.call
```
 console.log(toString.call(123)) //[object Number]
 console.log(toString.call('123')) //[object String]
 console.log(toString.call(undefined)) //[object Undefined]
 console.log(toString.call(true)) //[object Boolean]
 console.log(toString.call({})) //[object Object]
 console.log(toString.call([])) //[object Array]
 console.log(toString.call(function(){})) //[object Function]
```
 + 面试，笔试必考，框架开发必用，五星级知识点

- instanceof
```
 var arr=[]
 var arr = new Array()console.log(arr instanceof Array) //---------------> true
 console.log(date instanceof Date)     //---------------> true
 console.log(fn instanceof Function)   //------------> true
```
 + 注意：instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。

- constructor
```
 console.log(arr.constructor === Array)   //----------> true
 console.log(date.constructor === Date)   //-----------> true
 console.log(fn.constructor === Function) //-------> true
```
 + 根据对象的constructor属性判断 ： constructor
- Jquery中
 + jQuery提供一系列工具方法，用来判断数据类型，以弥补JavaScript原生的typeof运算符的不足。
 + 以下方法对参数进行判断，返回一个布尔值。
```
   jQuery.isArray()：是否为数组。
   jQuery.isEmptyObject()：是否为空对象（不含可枚举的属性）。
   jQuery.isFunction()：是否为函数。
   jQuery.isNumeric()：是否为数字。
   jQuery.isPlainObject()：是否为使用“{}”或“new Object”生成的对象，而不是浏览器原生提供的对象。
   jQuery.isWindow()：是否为window对象。
   jQuery.isXMLDoc()：判断一个DOM节点是否处于XML文档之中。
```
6. 常用的正则 + replace进阶
- <a href="https://github.com/zzc5464/for-myself">常用的正则</a>
- <a href="https://github.com/zzc5464/replace-upgrade">replace</a>
 + replace是js中最难的一个函数


set